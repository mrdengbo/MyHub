例如：int a[5] = {5,4,3,2,1};
<1>i = 0;i < 5;j < 5
	 k = 0, 
	 j = 1; a[0] > a[1],成立，k = j = 1;
	 j = 2; a[1] > a[2],成立，k = j = 2;
	 j = 3; a[2] > a[3],成立，k = j = 3;
	 j = 4; a[3] > a[4],成立，k = j = 4; 
	 内存循环完成，k = 4，i = 0，k != i,交换a[k]和a[i]的值
	 交换完成后，{1,4,3,2,5}
<2>i = 1;i < 5;j < 5
	  k = 1,
	  j = 2;a[1] > a[2],成立，k = j = 2
	  j = 3;a[2] > a[3],成立，k = j = 3
	  j = 4;a[3] > a[4],不成了
	  内存循环完成，k = 3,i = 1，k！= i,交换a[k]和a[i]的值
	  交换完成后，{1,2,3,4,5}
<3>i = 2;i < 5;j < 5
	 k = 2,
	 j = 3,a[2] > a[3] ,不成立
	 j = 4,a[2] > a[4],不成立
	 内存循环完成，k = 2, i = 2,k == i，不交换a[k]和a[i]的值
	 数组内容依旧为{1,2,3,4,5}

<4>i = 3; i < 5;j < 5
	 k = 3;
	 j = 4, a[3] > a[4] ,不成立

<5>i = 4;i < 5;j < 5
	 k = 4;
	 j = 5; j < 5,不成立，退出内存循环
	 k = 4,i = 4 ,k == i ,不交换a[k]和a[i]的值
	 
	 i++==>i = 5,循环结束。最终a[5] = {1,2,3,4,5};
	 
选择排序的思想。
	 首先，定义一个交换值k，把第一个数据的值赋给k，默认k存最小的数据，然后依次让后面的数据和k相比，比它数据小的，
	 就让k和比它小的数据交换位置。判断数据的值是否改变。若是改变了。把k的值与a[0]交换。然后k 与a[1]比较数据。
	 以此类推。最后得到从小到大的数据。
	 
	 比如说有5个数字  5,4,3,2,1
	 定义一个k = 0；
	 首先k 指向第一个元素;
	 
	 
	 				 第一轮后       第二轮	       第三轮     第四轮	
k -> | 5 |				 | 1 |					| 1 |			 | 1 |        | 1 |
		 | 4 |				 | 4 |					| 2 |		   | 2 |				| 2 |
		 | 3 |-------->| 3 |--------->| 3 |----->| 3 |------->| 3 |
		 | 2 | 				 | 2 |	        | 4 |      | 4 |        | 4 |
		 | 1 |k = 4--> | 5 |	        | 5 |			 | 5 |				| 5 |
												重新让k指向
												 第二个
		 原始